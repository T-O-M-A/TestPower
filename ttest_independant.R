# Test de moyenne bilatéral - T test simulation (Monte Carlo)
# Objectif: Estimation de puissance 
# dans le cas: 2 échantillons indépendants de même variance.

# Clear environment
rm(list=ls())

#-----------------------------------------------------------------------
# Paramètres de la simulation
#-----------------------------------------------------------------------



# Taille des échantillons pilotes
# Non nécessairement égaux (dépend des ressources disponibles)
npilote_congruent = 40
npilote_incongruent = 25

# Taille des tirages pour Monte-Carlo.
# On les prends égaux de préférence.
n1 = 50
n2 = 50
# Number of runs for MC
runs = 1000


# Difference between the means
# no difference to test the alpha level (type I errors)
meand = 0
# non null to test how often the existing effect is found (power)
meand = 0.04

# Standard deviation of both samples
s = 0.1

# Erreur de 1ère espèce
alpha = 0.05


#---------------------------------------------------
#                     pilote 
#---------------------------------------------------


pilote_ttest_independants<-function(npilote_congruent, npilote_incongruent, meand, s)
{
  # On simule 2 échantillons "réels"
  congruent = rnorm(npilote_congruent,mean = 0,sd = s)
  incongruent = rnorm(npilote_incongruent,mean = meand,sd = s)
  # On estime la différence de moyenne et l'écart-type
  mean1 = mean(congruent)
  mean2 = mean(incongruent)
  # On suppose leur écart-type égal.
  # On l'estime donc par une moyenne de leur écart-type empirique.
  ecart_type = (sd(congruent)+sd(incongruent))/2
  # On retourne l'approximation de l'étude pilote
  return (c(mean1, mean2, ecart_type))
}



#---------------------------------------------------
# t-test simulations (Monte-Carlo)
#---------------------------------------------------

ttest_independants_MC<-function(runs, pilote, n1, n2, alpha){
 
  
   # On récupère les paramètres de l'étude pilote pour le MC.
  mean1 = pilote[1]
  mean2 = pilote[2]
  s = pilote[3]
  meand = mean2-mean1
  
  # Independent variable (predictor)
  x = c(
    rep(1,n1),	# group 1
    rep(2,n2)	# group 2
  )
  x = factor(x)
  
  # Perform runs (with stochastic sampling)
  tval = numeric(runs) # to store resulting t statistics
  tval_hand = numeric(runs) # to store resulting t statistics (computed by hand)
  pval = numeric(runs) # to store resulting p-values
  for (r in 1:runs) {
    # Generate random independent samples with normal distributions
    # for the dependent variable (predicted)
    y = c(
      rnorm(n1,mean=mean1,sd=s),
      rnorm(n2,mean=mean2,sd=s)
    )
    
    # Run model : on stocke les t-statistics et p-values
    # du modèle généré par R.
    model = t.test(y~x, var.equal=TRUE)
    tval[r] = model$statistic
    pval[r] = model$p.value
    
    # Hand-made equivalent to compute the t statistic
    # (will produce the same value as model$statistic)
    # DV for each group
    y1 = y[x==1]
    y2 = y[x==2]
    # Pooled standard deviation
    s12 = sqrt((sd(y1)^2+sd(y2)^2)/(n1+n2-2))
    tval_hand[r] = (mean(y1)-mean(y2))/(s12*sqrt((1/n1)+(1/n2)))
  }
  
  # Display the resulting statistics
  res = data.frame(
    t_statistic=tval,
    t_statistic_hand=tval_hand,
    p_value=pval
  )
  head(res,10)
  
  # Histograms for the observed t statistic on independent samples
  hist(tval,freq=FALSE,breaks=100)
  # Curve for the theoretical distribution for independent samples
  # (if mean = 0)
  s_range = seq(min(tval),max(tval),length.out=100)
  lines(s_range,dt(s_range,n1+n1-2))
  # if the histogram and curve match,
  # this means we cannot differentiate the results at chance level)
  
  # Directly exploit the pvalues generated by the model
  # to get the power of type I error rate (depending on meand value)
  # p5_model devrait tendre vers 0.05 si meand = 0
  # p5_model nous donne la puissance du test si meand != 0
  nb = sum(pval<alpha)
  # --> signifie que si meand = 0, on conclue à tort un effet à un ratio p5_model
  # si meand != 0, on affirme à raison un effet à un ratio p5_model
  p5_model = nb/runs
  
  # Compute the ratio of type I errors (should be <0.5)
  # equivalent to what precedes (to help you understand the computations)
  # (using the t statistic table/function)
  # p5_hand devrait etre égal à p5_model
  thr_low = qt(alpha/2,n1+n2-2,lower.tail=T)
  thr_upp = qt(alpha/2,n1+n2-2,lower.tail=F)
  nb = sum(tval<thr_low | tval>thr_upp)
  p5_hand = nb/runs
  
  # On calcule la puissance théorique (analytique) du t-test avec le package power:
  # NB: Dans le cas n1 = n2 = n, on devrait avoir p5_package = p5_model = p5_hand.
  p5_package = power.t.test(n=(n1+n2)/2, d = meand/s, sig.level = alpha, type = "two.sample", alternative = "two.sided")$power
  
  # Add these results to the global table
  results = data.frame(
    n1=n1,
    n2=n2,
    mean_diff=meand,
    sd=s,
    runs=runs,
    p5_model=p5_model,
    p5_hand=p5_hand,
    p5_package=p5_package 
  )
  results
}
pilote = pilote_ttest_independants(npilote_congruent, npilote_incongruent, meand, s)
ttest_independants_MC(runs, pilote, n1, n2, alpha)
# If meand=0, we expect the proportion of p-values<0.05 to be roughly at 0.05 (type I error rate)
# If meand!=0, we expect the proportion of p-values<0.05 to be the highest possible (power)
