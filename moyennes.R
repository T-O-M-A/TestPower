# UN ECHANTILLON



#---------------------------------------------------
#                     calcul du n 
#---------------------------------------------------


calcul_n<-function(puissance,puissances,tailles){
  if (is.null(puissance)){
    return (-1)
  } else {
    i = 0
    p_cour = 0
    while((i < 16) && (p_cour < puissance)){
      i = i+1
      p_cour = puissances[i]
    }
    if(i == 16){
      return (0)
    } else {
      n2 = tailles[i]
      p2 = puissances[i]
      if (i==1){
        n1 = 0  
        p1 = 0
      } else {
        n1 = tailles[i-1]
        p1 = puissances[i-1]
      }
      pente = (p2-p1)/(n2-n1)
      if (pente == 0){
        n_calc = (n2-n1)/2
      } else {
        n_calc = (puissance-p1)/pente + n1
      }
      n_calc = ceiling(n_calc)
      return (n_calc)
    }
  }
}


#---------------------------------------------------
#                     pilote 
#---------------------------------------------------


pilote_ttest_normal<-function(npilote, meand, sd, runs_bs_pilote,dest_pilote)
{
  # On simule un échantillon "réel" de loi N(meand,s)
  echantillon = rnorm(npilote,mean = meand,sd = sd)
  # On détermine les paramètres empiriques du pilote
  meand2 = mean(echantillon)
  ecart_type = sd(echantillon)
  # On détermine l'intervalle de confiance de la moyenne avec la fonction confint de R
  conf_mean = t.test(echantillon,conf.level = alpha)$conf.int
  # On détermine l'intervalle de confiance de l'écart-type avec un Bootstrap
  table_sd = numeric(runs_bs_pilote)
  for(i in 1:runs_bs_pilote)
  {
    # On choisit pour le boostrap des sous-ensembles de taille 80% de la taille de l'échantillon 
    n_bs = ceiling(0.8*npilote)
    table_sd[i] = sd((sample(echantillon,n_bs,replace=T)))
  }
  table_sd_sorted = sort(table_sd)
  conf_sd = c(table_sd_sorted[floor(runs_bs_pilote*alpha)],table_sd_sorted[floor(runs_bs_pilote*(1-alpha))])
  # On trace le pilote
  jpeg(dest_pilote)
  redleger = rgb(1,0,0)
  redfort = rgb(0.3,0,0)
  h<-hist(echantillon, breaks=10, col=redleger, main="Histogram with Normal Curve")
  
  xfit<-seq(min(echantillon),max(echantillon),length=40)
  yfit1<-dnorm(xfit,mean=meand2,sd=ecart_type)
  yfit1 <- yfit1*diff(h$mids[1:2])*length(echantillon)
  lines(xfit, yfit1, col=redfort, lwd=2) 
  yfit2 <- dnorm(xfit,sd=ecart_type)
  yfit2 <- yfit2*diff(h$mids[1:2])*length(echantillon)
  lines(xfit, yfit2, col="blue", lwd=2) 
  legend('topleft',c('Référence nulle','Echantillon'),
         fill = c("blue", redfort), bty = 'n',
         border = NA)
  dev.off()
  # On retourne l'approximation de l'étude pilote
  return (list(ecart_type=ecart_type, mean = meand2, conf_mean=conf_mean, conf_sd=conf_sd))
}


#---------------------------------------------------
# Monte-Carlo pour échantillon unique
#---------------------------------------------------


MC<-function(n, runs, meand, sd){
  # Variable (predictor)
  x = c(
    rep(1,n)	# group 
  )
  x = factor(x)
  
  # Perform runs (with stochastic sampling)
  tval = numeric(runs) # to store resulting t statistics
  tval_hand = numeric(runs) # to store resulting t statistics (computed by hand)
  pval = numeric(runs) # to store resulting p-values
  
  # On applique 2 Monte Carlo : 
  # un pour meandinf et un pour meandsup
  #print(meand)
  for (r in 1:runs) {
    
    
    # Generate random independent samples with normal distributions
    # for the dependent variable (predicted)
    y = c(
      rnorm(n,mean=meand,sd=sd)
    )
    
    # Run model : on stocke les t-statistics et p-values
    # du modèle généré par R.
    model = t.test(y)
    tval[r] = model$statistic
    pval[r] = model$p.value
    
    # Hand-made equivalent to compute the t statistic
    # (will produce the same value as model$statistic)
    
    # DV for group
    y1 = y[x==1]
    
    # Pooled standard deviation
    s12 = sd(y1)
    tval_hand[r] = mean(y1)/(s12/sqrt(n))
  }
  # Directly exploit the pvalues generated by the model
  # to get the power of type I error rate (depending on meand value)
  # p5_model devrait tendre vers 0.05 si meand = 0
  # p5_model nous donne la puissance du test si meand != 0
  nb = sum(pval<alpha)
  # --> signifie que si meand = 0, on conclue à tort un effet à un ratio p5_model
  # si meand != 0, on affirme à raison un effet à un ratio p5_model
  p5_model = nb/runs # Attention : le model est ici bilatéral
  # Compute the ratio of type I errors (should be <0.5)
  # equivalent to what precedes (to help you understand the computations)
  # (using the t statistic table/function)
  # On doit avoir p5_hand = p5_model
  thr_low = qt(alpha/2,n-1,lower.tail=T)
  thr_upp = qt(alpha/2,n-1,lower.tail=F)
  nb = sum(tval_hand>thr_upp | tval_hand<thr_low)
  p5_hand = nb/runs
  
  # On calcule la puissance théorique (analytique) du t-test avec le package power:
  # p5_model devrait tendre vers p5_package lorsque runs -> infinite.
  p5_package = power.t.test(n=n, d = meand/sd, sig.level = alpha, type = "one.sample", alternative = "two.sided")$power
  return(list(meand = meand, sd = sd, p5_model = p5_model, p5_hand = p5_hand, p5_package = p5_package ))
}


#---------------------------------------------------
# t-test simulations (Monte-Carlo)
#---------------------------------------------------


ttest_normal<-function(n, runs, pilote,i,vect){
  
  # On récupère les informations du pilote
  # Pour la moyenne
  
  if(vect){
    mean = pilote[[1]]$mean   # moyenne empirique du pilote
    conf_sd = pilote[[1]]$conf_sd # intervalle de confiance pour l'écart-type du pilote au seuil alpha = 0.05
    conf_mean = pilote[[1]]$conf_mean # intervalle de confiance pour la moyenne du pilote au seuil alpha = 0.05
    ecart_type = pilote[[1]]$ecart_type  # ecart_type empirique du pilote
  }
  else{
    mean = pilote$mean
    conf_sd = pilote$conf_sd
    conf_mean = pilote$conf_mean
    ecart_type = pilote$ecart_type
  }
  # Bornes de l'intervalle de confiance de la moyenne
  meaninf = conf_mean[1]
  meansup = conf_mean[2]
  # Pour l'écart-type
  # Bornes de l'intervalle de confiance de l'écart-type
  sdinf = conf_sd[1]
  sdsup = conf_sd[2]        
  MC_inf = MC(n,runs,meaninf,sdsup)
  MC_sup = MC(n,runs,meansup,sdinf)
  MC_moy = MC(n,runs,mean,ecart_type)
  
  
  IC_Puissance_model = c(MC_inf$p5_model,MC_sup$p5_model)
  IC_Puissance_hand = c(MC_inf$p5_hand,MC_sup$p5_hand)
  IC_Puissance_package = c(MC_inf$p5_package,MC_sup$p5_package)
  
  # On présente les résultats sur la puissance:
  # La puissance à partir des paramètres empiriques du pilote, 
  # Puis les intervalles de confiance de la puissance calculés
  # à partir des intervalles de confiance des paramètres.
  # NB : 
  Puissance_moy_hand = MC_moy$p5_hand
  Puissance_moy_model = MC_moy$p5_model
  Puissance_moy_package = MC_moy$p5_package
  results = data.frame(
    n=n,
    runs = runs,
    Puissance_moy_hand = Puissance_moy_hand,
    IC_Puissance_hand_inf = IC_Puissance_hand[1],
    IC_Puissance_hand_sup = IC_Puissance_hand[2],
    Puissance_moy_model = Puissance_moy_model,
    IC_Puissance_model_inf = IC_Puissance_model[1],
    IC_Puissance_model_sup = IC_Puissance_model[2],
    Puissance_moy_package = MC_moy$p5_package,
    IC_Puissance_package_inf = IC_Puissance_package[1],
    IC_Puissance_package_sup = IC_Puissance_package[2]
  )
  return (results)
}



#---------------------------------------------------
# Test : Puissance en fonction de la taille de l'échantillon.
# (Calcul basé sur l'algorithme de Monte Carlo )
#---------------------------------------------------

Puissance_un<-function(npilote = 20, meand = 0.1, sd = 0.3, runs_bs_pilote = 1000, runs_MC = 1000, taille_max = 100, dest_puissance, dest_pilote, puissance = NULL){
  # Création du pilote
  pilote = pilote_ttest_normal(npilote, meand, sd, runs_bs_pilote,dest_pilote)
  #print(pilote)
  # On regarde la puissance en fonction de la taille d'échantillon
  # (!= npilote, qui est la taille du pilote.
  # ici, la taille de l'échantillon correspond à la taille des tirages pour Monte-Carlo)
  tailles = seq(from = 20, to = taille_max, length.out = 15)
  longueur = length(tailles)
  puissances = numeric(longueur)
  IC_low_width = numeric(longueur)
  IC_up_width = numeric(longueur)
  for (i in 1:longueur){
    results = ttest_normal(tailles[i],runs_MC,pilote,0,FALSE)
    puissances[i] = results$Puissance_moy_hand
    IC_low_width[i] =  puissances[i] - results$IC_Puissance_hand_inf
    IC_up_width[i] = results$IC_Puissance_hand_sup - puissances[i]
  }
  jpeg(dest_puissance)
  plotCI(tailles, puissances, uiw = IC_up_width, liw = IC_low_width, type = "o", barcol = "red")
  dev.off()
  results # affiche les puissances pour le dernier tirage de Monte Carlo
  return(calcul_n(puissance,puissances,tailles))
}


TEST_taille_pilote<-function(tailles_pilote, meand,sd,runs_bs_pilote,runs_MC){
  pilotes = array(list(NULL),dim = length(tailles_pilote))
  longueur = length(tailles_pilote)
  print(longueur)
  puissances = rep(0,longueur)
  IC_low_width = numeric(longueur)
  IC_up_width = numeric(longueur)
  for (i in 1:longueur){
    
    pilotes[[i]] = pilote_ttest_normal(tailles_pilote[i],meand,sd,runs_bs_pilote)
    
  }
  for(i in 1:longueur){
    results = ttest_normal(taille,runs_MC,pilotes[i],i,TRUE)
    puissances[i] = results$Puissance_moy_hand
    IC_low_width[i] =  puissances[i] - results$IC_Puissance_hand_inf
    IC_up_width[i] = results$IC_Puissance_hand_sup - puissances[i]
  }
  results # affiche les puissances pour le dernier tirage de Monte Carlo
}



# ECHANTILLONS INDEPENDANTS

#---------------------------------------------------
#                     pilote 
#---------------------------------------------------


pilote_ttest_independants<-function(npilote_congruent, npilote_incongruent, meand, s, runs_bs_pilote, dest_pilote)
{
  alpha = 0.05
  # On simule 2 échantillons "réels"
  congruent = rnorm(npilote_congruent,mean = 0,sd = s)
  incongruent = rnorm(npilote_incongruent,mean = meand,sd = s)
  # On estime la différence de moyenne et l'écart-type
  mean1 = mean(congruent)
  mean2 = mean(incongruent)
  meand2 = mean2 - mean1
  # On suppose leur écart-type égal.
  # On l'estime donc par une moyenne de leur écart-type empirique.
  ecart_type = (sd(congruent)+sd(incongruent))/2
  # On détermine l'intervalle de confiance pour la moyenne du ttest
  conf_mean = t.test(incongruent,congruent,conf.level = alpha)$conf.int
  # On détermine l'intervalle de confiance de l'écart-type avec un Bootstrap
  table_sd = numeric(runs_bs_pilote)
  for(i in 1:runs_bs_pilote)
  {
    # On choisit pour le boostrap des sous-ensembles de taille 80% de la taille de l'échantillon 
    #(On estime toujours sd par une moyenne des sd des 2 échantillon)
    n_bs_congruent = ceiling(0.8*npilote_congruent)
    n_bs_incongruent = ceiling(0.8*npilote_incongruent)
    table_sd[i] = (sd((sample(congruent,n_bs_congruent,replace=T))) + sd((sample(incongruent,n_bs_incongruent,replace=T))))/2
  }
  table_sd_sorted = sort(table_sd)
  conf_sd = c(table_sd_sorted[floor(runs_bs_pilote*alpha)],table_sd_sorted[floor(runs_bs_pilote*(1-alpha))])
  # On trace le pilote
  jpeg(dest_pilote)
  densCongruent <- density(congruent)
  densIncongruent <- density(incongruent)
  histCongruent <-hist(congruent, breaks=10, plot = FALSE)
  histIncongruent <- hist(incongruent, breaks=10, plot = FALSE)
  xlim <- range(histIncongruent$breaks,histCongruent$breaks)
  ylim <- range(0,histIncongruent$density,histCongruent$density)
  #ylim <- c(0,max(histCongruent$density,max(histIncongruent$density)))
  plot(histCongruent,xlim = xlim, ylim = ylim,
       col = rgb(1,0,0,0.4),xlab = 'congruent',
       freq = FALSE, ## relative, not absolute frequency
       main = 'Distribution')
  opar <- par(new = FALSE)
  plot(histIncongruent,xlim = xlim, ylim = ylim,
       xaxt = 'n', yaxt = 'n', ## don't add axes
       col = rgb(0,0,1,0.4), add = TRUE,
       freq = FALSE) ## relative, not absolute frequency
  ## add a legend in the corner
  legend('topleft',c('Congruent','Incongruent'),
         fill = rgb(1:0,0,0:1,0.4), bty = 'n',
         border = NA)
  par(opar)
  ## plot first density
  xfit1<-seq(min(congruent),max(congruent),length=40)
  yfit1<-dnorm(xfit1,mean=mean1,sd=ecart_type)
  yfit1 <- yfit1*diff(histCongruent$mids[1:2])*length(congruent)
  lines(xfit1, yfit1, col=rgb(1,0,0,0.4), lwd=2) 
  ## plot second density
  xfit2<-seq(min(incongruent),max(incongruent),length=40)
  yfit2<-dnorm(xfit2,mean=mean2,sd=ecart_type)
  yfit2 <- yfit2*diff(histIncongruent$mids[1:2])*length(incongruent)
  lines(xfit2, yfit2, col=rgb(0,0,1,0.4), lwd=2) 
  
  
  dev.off()
  # On retourne l'approximation de l'étude pilote
  return (list(ecart_type=ecart_type, mean = meand2, conf_mean=conf_mean, conf_sd=conf_sd))
}



#---------------------------------------------------
# Monte-Carlo pour 2 échantillons indépendants 
#---------------------------------------------------

MC_ind<-function(n1, n2, runs, meand, sd){
  
  alpha = 0.05
  # Independent variable (predictor)
  x = c(
    rep(1,n1),	# group 1
    rep(2,n2)	# group 2
  )
  x = factor(x)
  
  # Perform runs (with stochastic sampling)
  tval = numeric(runs) # to store resulting t statistics
  tval_hand = numeric(runs) # to store resulting t statistics (computed by hand)
  pval = numeric(runs) # to store resulting p-values
  for (r in 1:runs) {
    # Generate random independent samples with normal distributions
    # for the dependent variable (predicted)
    y = c(
      rnorm(n1,mean=0,sd=sd),
      rnorm(n2,mean=meand,sd=sd)
    )
    
    # Hand-made equivalent to compute the t statistic
    # (will produce the same value as model$statistic)
    # DV for each group
    y1 = y[x==1]
    y2 = y[x==2]
    # Pooled standard deviation
    s12 = sqrt((sd(y1)^2+sd(y2)^2)/(n1+n2-2))
    tval_hand[r] = (mean(y1)-mean(y2))/(s12*sqrt((1/n1)+(1/n2)))
    
    
    # Run model : on stocke les t-statistics et p-values
    # du modèle généré par R.
    model = t.test(y2, y1, var.equal=TRUE)
    tval[r] = model$statistic
    pval[r] = model$p.value
    
  }
  
  # Display the resulting statistics
  res = data.frame(
    t_statistic=tval,
    t_statistic_hand=tval_hand,
    p_value=pval
  )
  head(res,10)
  
  
  
  # Directly exploit the pvalues generated by the model
  # to get the power of type I error rate (depending on meand value)
  # p5_model devrait tendre vers 0.05 si meand = 0
  # p5_model nous donne la puissance du test si meand != 0
  nb = sum(pval<alpha)
  # --> signifie que si meand = 0, on conclue à tort un effet à un ratio p5_model
  # si meand != 0, on affirme à raison un effet à un ratio p5_model
  p5_model = nb/runs
  
  # Compute the ratio of type I errors (should be <0.5)
  # equivalent to what precedes (to help you understand the computations)
  # (using the t statistic table/function)
  # p5_hand devrait etre égal à p5_model
  thr_low = qt(alpha/2,n1+n2-2,lower.tail=T)
  thr_upp = qt(alpha/2,n1+n2-2,lower.tail=F)
  nb = sum(tval<thr_low | tval>thr_upp)
  p5_hand = nb/runs
  
  # On calcule la puissance théorique (analytique) du t-test avec le package power:
  # NB: Dans le cas n1 = n2 = n, on devrait avoir p5_package = p5_model = p5_hand.
  p5_package = power.t.test(n=(n1+n2)/2, d = meand/sd, sig.level = alpha, type = "two.sample", alternative = "two.sided")$power
  
  return(list(meand = meand, sd = sd, p5_model = p5_model, p5_hand = p5_hand, p5_package = p5_package ))
}

#---------------------------------------------------
# t-test simulations (Monte-Carlo)
#---------------------------------------------------

ttest_independants<-function(n1, n2, runs, pilote){
  
  # On récupère les informations du pilote
  # Pour la moyenne
  mean = pilote$mean # moyenne empirique du pilote
  conf_mean = pilote$conf_mean # intervalle de confiance pour la différence moyenne du pilote au seuil alpha = 0.05
  # Bornes de l'intervalle de confiance de la différence de moyenne
  meaninf = conf_mean[1]
  meansup = conf_mean[2]
  # Pour l'écart-type
  ecart_type = pilote$ecart_type  # ecart_type empirique du pilote (le même pour les 2 échantillons)
  conf_sd = pilote$conf_sd # intervalle de confiance pour l'écart-type du pilote au seuil alpha = 0.05
  # Bornes de l'intervalle de confiance de l'écart-type
  sdinf = conf_sd[1]
  sdsup = conf_sd[2]
  
  MC_inf = MC_ind(n1,n2,runs,meaninf,sdsup)
  MC_sup = MC_ind(n1,n2,runs,meansup,sdinf)
  MC_moy = MC_ind(n1,n2,runs,mean,ecart_type)
  
  
  IC_Puissance_model = c(MC_inf$p5_hand,MC_sup$p5_hand)
  IC_Puissance_hand = c(MC_inf$p5_model,MC_sup$p5_model)
  IC_Puissance_package = c(MC_inf$p5_package,MC_sup$p5_package)
  
  # On présente les résultats sur la puissance:
  # La puissance à partir des paramètres empiriques du pilote, 
  # Puis les intervalles de confiance de la puissance calculés
  # à partir des intervalles de confiance des paramètres.
  # NB : 
  Puissance_moy_hand = MC_moy$p5_hand
  Puissance_moy_model = MC_moy$p5_model
  Puissance_moy_package = MC_moy$p5_package
  results = data.frame(
    n1=n1,
    n2=n2,
    runs = runs,
    Puissance_moy_hand = Puissance_moy_hand,
    IC_Puissance_hand_inf = IC_Puissance_hand[1],
    IC_Puissance_hand_sup = IC_Puissance_hand[2],
    Puissance_moy_model = Puissance_moy_model,
    IC_Puissance_model_inf = IC_Puissance_model[1],
    IC_Puissance_model_sup = IC_Puissance_model[2],
    Puissance_moy_package = MC_moy$p5_package,
    IC_Puissance_package_inf = IC_Puissance_package[1],
    IC_Puissance_package_sup = IC_Puissance_package[2]
  )
  return (results)
}


#---------------------------------------------------
# Test : Puissance en fonction de la taille de l'échantillon.
# (Calcul basé sur l'algorithme de Monte Carlo )
#---------------------------------------------------

Puissance_ind<-function(npilote_congruent = 20, npilote_incongruent = 20, meand = 0.4, sd = 0.3, runs_bs_pilote = 1000, runs_MC = 1000, taille_max = 100, dest_puissance, dest_pilote, puissance = NULL){
  # Environment
  library(gplots)
  # Création du pilote
  pilote = pilote_ttest_independants(npilote_congruent, npilote_incongruent, meand, sd, runs_bs_pilote, dest_pilote)
  # On regarde la puissance en fonction de la taille d'échantillon
  # (!= npilote, qui est la taille du pilote.
  # ici, la taille de l'échantillon correspond à la taille des tirages pour Monte-Carlo)
  tailles = seq(from = 20, to = taille_max, length.out = 15)
  longueur = length(tailles)
  puissances = numeric(longueur)
  IC_low_width = numeric(longueur)
  IC_up_width = numeric(longueur)
  for (i in 1:longueur){
    # On prend les mêmes tailles d'échantillonage pour les tirages de Monte-Carlo
    results = ttest_independants(tailles[i], tailles[i], runs_MC,pilote)
    puissances[i] = results$Puissance_moy_hand
    IC_low_width[i] =  puissances[i] - results$IC_Puissance_hand_inf
    IC_up_width[i] = results$IC_Puissance_hand_sup - puissances[i]
  }
  jpeg(dest_puissance)
  plotCI(tailles, puissances, uiw = IC_up_width, liw = IC_low_width, type = "o", barcol = "red")
  dev.off()
  results # affiche les puissances pour le dernier tirage de Monte Carlo
  return(calcul_n(puissance,puissances,tailles))
}
## ECHANTILLONS APPARIES



pilote_ttest_paired<-function(npilote, meand, s1, s2, cf, runs_bs_pilote, dest_pilote)
{
  alpha = 0.05
  # On simule 2 échantillons "réels"
  # tels que: leur différence de moyenne est meand,
  # les standard error des echantillons sont s1 et s2,
  # et le facteur de corrélation est cf.
  congruent = rnorm(npilote,mean = 0,sd = s1)
  # Dans le cas apparié, on suppose que Y = a + bX + eps,
  # où eps est une normale centrée. On a donc:
  a = meand
  # puis var(Y) = b²var(X) + var(eps), et
  # cf = b/(s1s2)
  b = cf*(s1*s2)
  sd_eps = sqrt(s2^2-b^2*s1^2)  
  eps = rnorm(npilote,mean = 0,sd = sd_eps)
  incongruent = a + b*congruent + eps
  # On estime les paramètres du pilote
  mean1 = mean(congruent)
  mean2 = mean(incongruent)
  meand2 = mean2 - mean1
  ecart_type_congruent = sd(congruent)
  ecart_type_incongruent = sd(incongruent)
  cf_estime = cor(congruent, incongruent)
  # On détermine l'intervalle de confiance pour la moyenne du ttest
  conf_mean = t.test(incongruent,congruent,paired = TRUE)$conf.int
  # On détermine l'intervalle de confiance des écarts-type et du coefficient de corrélation avec un Bootstrap
  table_sd1 = numeric(runs_bs_pilote)
  table_sd2 = numeric(runs_bs_pilote)
  for(i in 1:runs_bs_pilote)
  {
    # On choisit pour le boostrap des sous-ensembles de taille 80% de la taille de l'échantillon 
    n_bs = ceiling(0.8*npilote)
    table_sd1[i] = sd((sample(congruent,n_bs,replace=T)))
    table_sd2[i] = sd((sample(incongruent,n_bs,replace=T)))
  }
  table_sd1_sorted = sort(table_sd1)
  table_sd2_sorted = sort(table_sd2)
  conf_sd1 = c(table_sd1_sorted[floor(runs_bs_pilote*alpha)],table_sd1_sorted[floor(runs_bs_pilote*(1-alpha))])
  conf_sd2 = c(table_sd2_sorted[floor(runs_bs_pilote*alpha)],table_sd2_sorted[floor(runs_bs_pilote*(1-alpha))])
  # On trace le pilote
  jpeg(dest_pilote)
  densCongruent <- density(congruent)
  densIncongruent <- density(incongruent)
  histCongruent <-hist(congruent, breaks=10, plot = FALSE)
  histIncongruent <- hist(incongruent, breaks=10, plot = FALSE)
  xlim <- range(histIncongruent$breaks,histCongruent$breaks)
  ylim <- range(0,histIncongruent$density,histCongruent$density)
  #ylim <- c(0,max(histCongruent$density,max(histIncongruent$density)))
  plot(histCongruent,xlim = xlim, ylim = ylim,
       col = rgb(1,0,0,0.4),xlab = 'congruent',
       freq = FALSE, ## relative, not absolute frequency
       main = 'Distribution')
  opar <- par(new = FALSE)
  plot(histIncongruent,xlim = xlim, ylim = ylim,
       xaxt = 'n', yaxt = 'n', ## don't add axes
       col = rgb(0,0,1,0.4), add = TRUE,
       freq = FALSE) ## relative, not absolute frequency
  ## add a legend in the corner
  legend('topleft',c('Congruent','Incongruent'),
         fill = rgb(1:0,0,0:1,0.4), bty = 'n',
         border = NA)
  par(opar)
  ## plot first density
  xfit1<-seq(min(congruent),max(congruent),length=40)
  yfit1<-dnorm(xfit1,mean=mean1,sd=ecart_type_congruent)
  yfit1 <- yfit1*diff(histCongruent$mids[1:2])*length(congruent)
  lines(xfit1, yfit1, col=rgb(1,0,0,0.4), lwd=2) 
  ## plot second density
  xfit2<-seq(min(incongruent),max(incongruent),length=40)
  yfit2<-dnorm(xfit2,mean=mean2,sd=ecart_type_incongruent)
  yfit2 <- yfit2*diff(histIncongruent$mids[1:2])*length(incongruent)
  lines(xfit2, yfit2, col=rgb(0,0,1,0.4), lwd=2) 
  
  
  dev.off()
  # On retourne l'approximation de l'étude pilote
  return (list(ecart_type_congruent=ecart_type_congruent, ecart_type_incongruent=ecart_type_incongruent, mean=meand2, conf_mean=conf_mean, conf_sd1=conf_sd1,conf_sd2 = conf_sd2))
}



#---------------------------------------------------
# Monte-Carlo pour 2 échantillons appariés 
#---------------------------------------------------

MC_ap<-function(n, runs, meand, s1, s2, cf){
  alpha = 0.05
  # Independent variable (predictor)
  x = c(
    rep(1,n)	# group 
  )
  x = factor(x)
  
  # Perform runs (with stochastic sampling)
  tval = numeric(runs) # to store resulting t statistics
  tval_hand = numeric(runs) # to store resulting t statistics (computed by hand)
  pval = numeric(runs) # to store resulting p-values
  
  sz = sqrt(s1^2+s2^2-(2*cf*s1*s2))
  
  for (r in 1:runs) {
    # Generate random independent samples with normal distributions
    # for the dependent variable (predicted)
    y = c(
      rnorm(n,mean=meand,sd=sz)
    )
    
    # Run model : on stocke les t-statistics et p-values
    # du modèle généré par R.
    model = t.test(y)
    tval[r] = model$statistic
    pval[r] = model$p.value
    
    # Hand-made equivalent to compute the t statistic
    # (will produce the same value as model$statistic)
    # DV for group
    y1 = y[x==1]
    # Pooled standard deviation
    s12 = sd(y1)
    tval_hand[r] = mean(y1)/(s12/sqrt(n))
  }
  
  # Display the resulting statistics
  res = data.frame(
    t_statistic=tval,
    t_statistic_hand=tval_hand,
    p_value=pval
  )
  head(res,10)
  
  
  # Directly exploit the pvalues generated by the model
  # to get the power of type I error rate (depending on meand value)
  # p5_model devrait tendre vers 0.05 si meand = 0
  # p5_model nous donne la puissance du test si meand != 0
  nb = sum(pval<alpha)
  # --> signifie que si meand = 0, on conclue à tort un effet à un ratio p5_model
  # si meand != 0, on affirme à raison un effet à un ratio p5_model
  p5_model = nb/runs
  
  # Compute the ratio of type I errors (should be <0.5)
  # equivalent to what precedes (to help you understand the computations)
  # (using the t statistic table/function)
  # p5_hand devrait etre égal à p5_model
  thr_low = qt(alpha/2,n+n-2,lower.tail=T)
  thr_upp = qt(alpha/2,n+n-2,lower.tail=F)
  nb = sum(tval<thr_low | tval>thr_upp)
  p5_hand = nb/runs
  
  # On calcule la puissance théorique (analytique) du t-test avec le package power:
  # NB: Dans le cas n1 = n2 = n, on devrait avoir p5_package = p5_model = p5_hand.
  p5_package = power.t.test(n=n, d = (meand)/sz, sig.level = alpha, type = "paired", alternative = "two.sided")$power
  
  return(list(meand = meand, sd = sd, p5_model = p5_model, p5_hand = p5_hand, p5_package = p5_package ))
}


#---------------------------------------------------
# t-test simulations (Monte-Carlo)
#---------------------------------------------------

ttest_paired<-function(n,runs, pilote,cf){
  
  # On récupère les informations du pilote
  # Pour la moyenne
  mean = pilote$mean # moyenne empirique du pilote
  conf_mean = pilote$conf_mean # intervalle de confiance pour la moyenne du pilote au seuil alpha = 0.05
  # Bornes de l'intervalle de confiance de la moyenne
  meaninf = conf_mean[1]
  meansup = conf_mean[2]
  # Pour les écarts-type
  ecart_type1 = pilote$ecart_type_congruent 
  ecart_type2 = pilote$ecart_type_incongruent
  conf_sd1 = pilote$conf_sd1
  conf_sd2 = pilote$conf_sd2
  # Bornes des intervalles de confiance des écarts-type
  sd1inf = conf_sd1[1]
  sd1sup = conf_sd1[2]
  sd2inf = conf_sd2[1]
  sd2sup = conf_sd2[2]
  MC_inf = MC_ap(n,runs,meaninf,sd1sup,sd2sup,cf)
  MC_sup = MC_ap(n,runs,meansup,sd1inf,sd2inf,cf)
  MC_moy = MC_ap(n,runs,mean,ecart_type1,ecart_type2,cf)
  
  IC_Puissance_model = c(MC_inf$p5_model,MC_sup$p5_model)
  IC_Puissance_hand = c(MC_inf$p5_hand,MC_sup$p5_hand)
  IC_Puissance_package = c(MC_inf$p5_package,MC_sup$p5_package)
  
  # On présente les résultats sur la puissance:
  # La puissance à partir des paramètres empiriques du pilote, 
  # Puis les intervalles de confiance de la puissance calculés
  # à partir des intervalles de confiance des paramètres.
  # NB : 
  Puissance_moy_hand = MC_moy$p5_hand
  Puissance_moy_model = MC_moy$p5_model
  Puissance_moy_package = MC_moy$p5_package
  results = data.frame(
    n=n,
    runs = runs,
    Puissance_moy_hand = Puissance_moy_hand,
    IC_Puissance_hand_inf = IC_Puissance_hand[1],
    IC_Puissance_hand_sup = IC_Puissance_hand[2],
    Puissance_moy_model = Puissance_moy_model,
    IC_Puissance_model_inf = IC_Puissance_model[1],
    IC_Puissance_model_sup = IC_Puissance_model[2],
    Puissance_moy_package = MC_moy$p5_package,
    IC_Puissance_package_inf = IC_Puissance_package[1],
    IC_Puissance_package_sup = IC_Puissance_package[2]
  )
  return (results)
}

#---------------------------------------------------
# Test : Puissance en fonction de la taille de l'échantillon.
# (Calcul basé sur l'algorithme de Monte Carlo )
#---------------------------------------------------

Puissance_ap<-function(npilote = 20, meand = 0.1, s1 = 0.3, s2 = 0.3, cf = 0.6, runs_bs_pilote = 1000, runs_MC = 1000, taille_max = 100, dest_puissance, dest_pilote, puissance = NULL){
  # Environment
  library(gplots)
  # Création du pilote
  pilote = pilote_ttest_paired(npilote, meand, s1, s2, cf, runs_bs_pilote, dest_pilote)
  # On regarde la puissance en fonction de la taille d'échantillon
  # (!= npilote, qui est la taille du pilote.
  # ici, la taille de l'échantillon correspond à la taille des tirages pour Monte-Carlo)
  tailles = seq(from = 20, to = taille_max, length.out = 15)
  longueur = length(tailles)
  puissances =numeric(longueur)
  IC_low_width = numeric(longueur)
  IC_up_width = numeric(longueur)
  for (i in 1:longueur){
    results = ttest_paired(tailles[i],runs_MC,pilote,cf)
    puissances[i] = results$Puissance_moy_hand
    IC_low_width[i] =  puissances[i] - results$IC_Puissance_hand_inf
    IC_up_width[i] = results$IC_Puissance_hand_sup - puissances[i]
  }
  jpeg(dest_puissance)
  plotCI(tailles, puissances, uiw = IC_up_width, liw = IC_low_width, type = "o", barcol = "red")
  dev.off()
  results # affiche les puissances pour le dernier tirage de Monte Carlo
  return(calcul_n(puissance,puissances,tailles))
}

## ANOVA


#---------------------------------------------------
# Fonctions intermédiaires
#---------------------------------------------------

sigma_m<-function(means,sample_sizes){
  res = 0
  for(i in 1:length(sample_sizes)){
    res = res + sample_sizes[i]*(means[i]-mean(means))^2 #à changer si les ni sont différents
  }
  res = sqrt(res/N(sample_sizes))
  return(res)
}

N<-function(sample_sizes){
  n = 0
  for (i in 1:length(sample_sizes)){
    n = n + sample_sizes[i];
  }
  return(n)
}


between_group_variance<-function(sample_sizes,means,y){
  bgv  = 0
  for(j in 1:length(sample_sizes)){
    bgv = bgv + sample_sizes[j]*(means[j]- mean(y))^2
  }
  return(bgv)
}


within_group_variance<-function(sample_sizes,means,y){
  wgv = 0
  indice = 0
  for(i in 1:length(sample_sizes)){
    for(j in 1:sample_sizes[i]){
      wgv = wgv + (y[indice + j] - means[i])^2 #mean(means)
    }
    indice = indice + sample_sizes[i]
  }
  return(wgv)
}
F<-function(means,sample_sizes,y,k){
  num = between_group_variance(sample_sizes,means,y)
  denom = within_group_variance(sample_sizes,means,y)
  f = (num/denom)*(N(sample_sizes) -k)/(k - 1)
  return(f)
}



#---------------------------------------------------
# Fisher-Snedecor test simulations (Monte-Carlo)
#---------------------------------------------------

pilote_anova<-function(k, sd, runs_bs_pilote,dest_pilote)
{
  alpha = 0.05
  # On simule k échantillon "réels" avec des lois normales de moyenne aléatoire dans [1,2]
  # de taille aléatoire entre 15 et 20
  randommeans = numeric(k)
  empiricmeans = numeric(k)
  randomsizes = numeric(k)
  empiricsizes = numeric(k)
  conf_mean = matrix(nrow = 2, ncol = k)
  conf_sd = matrix(nrow = 2, ncol = k)
  r = 20 - sample(1:500, 1)/100
  echantillon = matrix(nrow = r,ncol = k)
  for (i in 1:k){
    randommeans[i] = 2 - sample(1:1000, 1)/1000
    randomsizes[i] = r
    #randomsizes[i] = floor(20 - sample(1:1000, 1)/100)
    echantillon[,i] = rnorm(n = randomsizes[i], mean = randommeans[i], sd = sd)
    
    # On détermine les paramètres empiriques du pilote
    empiricmeans[i] = mean(echantillon[,i])
    
    # On détermine l'intervalle de confiance de la moyenne avec la fonction confint de R
    conf_mean[,i] = t.test(echantillon[,i])$conf.int
    # On détermine l'intervalle de confiance de l'écart-type avec un Bootstrap
    table_sd_i = numeric(randomsizes[i])
    for(j in 1:runs_bs_pilote)
    {
      # On choisit pour le boostrap des sous-ensembles de taille 80% de la taille de l'échantillon 
      n_bs = ceiling(0.8*randomsizes[i])
      table_sd_i[j] = sd((sample(echantillon[,i],n_bs,replace=T)))
    }
    table_sd_i_sorted = sort(table_sd_i)
    conf_sd[,i] = c(table_sd_i_sorted[floor(runs_bs_pilote*alpha)],table_sd_i_sorted[floor(runs_bs_pilote*(1-alpha))])
  }
  # Tracé des points
  numero_echantillon = matrix(nrow = r,ncol = k)
  for (i in 1:k){
    numero_echantillon[,i] = rep(i,r)
  }
  jpeg(dest_pilote)
  mp <- matplot(numero_echantillon,echantillon)
  lines(1:k,empiricmeans, pch = 21,col = "red")
  lines(1:k,randommeans, pch = 21,col = "blue")
  legend('topleft',c('Moyennes empiriques','Moyennes réelles'),
         fill = c("red", "blue"), bty = 'n',
         border = NA)
  
  #plot(1:k,randommeans,add=TRUE,xlim = xlim, ylim = ylim,pch = 21,col = "blue")
  dev.off()
  ecart_type = sd
  # On retourne l'approximation de l'étude pilote
  return (list(ecart_type=ecart_type, empiricmeans = empiricmeans, realmeans = randommeans, sizes = randomsizes, conf_mean=conf_mean, conf_sd=conf_sd))
}




#---------------------------------------------------
# Monte-Carlo pour ANOVA 
#---------------------------------------------------

MC_an<-function(n, runs, means_empirique, means, s, sample_sizes,k){
  
  
  alpha = 0.05
  k = length(sample_sizes)
  # Independent variable (predictor)
  x = c(
    rep(1,N(sample_sizes))	# group 
  )
  x = factor(x)
  
  # Perform runs (with stochastic sampling)
  fval_hand = numeric(runs)
  fval= numeric(runs) # to store resulting t statistics (computed by hand)
  for (r in 1:runs) {
    # Generate random independent samples with normal distributions
    # for the dependent variable (predicted)
    y = 1:N(sample_sizes)
    indice = 0
    for(i in 1:k){
      y[(indice+1):(indice + sample_sizes[i])] = c(rnorm(n=sample_sizes[i],mean=means_empirique[i],sd =s))
      indice = indice + sample_sizes[i]
    }
    # Hand-made equivalent to compute the t statistic
    # (will produce the same value as model$statistic)
    # DV for group
    y1 = y[x==1]
    # Pooled standard deviation
    #  s12 = sd(y1)
    fval_hand[r] = F(means_empirique,sample_sizes,y1,k)
    #  model = fisher.test(y)
    #fval[r] = model$statistic
  }
  ncp = (N(sample_sizes))*(sigma_m(means,sample_sizes)/s)^2
  thr = qf(p =  1 -alpha,df1 = k-1,df2 = N(sample_sizes) - k)
  #thr_upp = qt(alpha/2,n+n-2,lower.tail=F)
  nb = sum(fval_hand > thr)
  p5_hand = nb/runs
  means_empiriqueMC = c(rep(1,k))
  indice = 0
  for(i in 1:k){
    intervalle = y1[(indice+1) : (indice + sample_sizes[i])]
    means_empiriqueMC[i] = mean(intervalle)
    indice = indice + sample_sizes[i]
  }
  #p5_package = power.anova.test(groups = k,n = n1,between.var = between_group_variance(sample_sizes,means_empirique,y),within.var = within_group_variance(sample_sizes,means_empirique,y1) ,sig.level = alpha)$power
  p5_package = pwr.anova.test(f = sigma_m(means_empiriqueMC,sample_sizes)/s, k = k, n =n[1],sig.level = alpha)$power
  
  # Add these results to the global table
  results = data.frame(
    n=N(sample_sizes),
    mean_diff=mean(means),
    sd=s,
    runs=runs,
    p5_hand=p5_hand,
    p5_package=p5_package, 
    fval_mean = mean(fval_hand),
    thr = thr
  )
  return(list(sd = s, p5_hand = p5_hand, p5_package = p5_package ))
}


#---------------------------------------------------
# t-test simulations (Monte-Carlo)
#---------------------------------------------------

ttest_anova<-function(n,runs, pilote){
  
  # On récupère les informations du pilote
  sizes = pilote$sizes
  k = length(sizes)
  # Pour la moyenne
  empiricmeans = pilote$empiricmeans # moyenne empirique du pilote
  conf_mean = pilote$conf_mean # intervalle de confiance pour la moyenne du pilote au seuil alpha = 0.05
  means = pilote$realmeans
  # Bornes de l'intervalle de confiance de la moyenne
  empiricmeansinf = conf_mean[1,]
  empiricmeanssup = conf_mean[2,]
  # On calcule les valeurs de l'intervalle qui donneront des valeurs extrêmes pour la puissance
  for (i in 1:k){
    true_mean = means[i]
    emp_meaninf = empiricmeansinf[i]
    emp_meansup = empiricmeanssup[i]
    emp_mean = empiricmeans[i]
    inf = min(abs(true_mean-emp_meaninf),abs(true_mean-emp_meansup),abs(true_mean-emp_mean))
    sup = max(abs(true_mean-emp_meaninf),abs(true_mean-emp_meansup),abs(true_mean-emp_mean))
    if (inf == abs(true_mean-emp_meaninf)){
      empiricmeansinf[i] = emp_meaninf
    } else {
      if (inf == abs(true_mean-emp_meansup)){
        empiricmeansinf[i] = emp_meansup
      } else {
        empiricmeansinf[i] = emp_mean
      }
    }
    if (sup == abs(true_mean-emp_meaninf)){
      empiricmeanssup[i] = emp_meaninf
    } else {
      if (sup == abs(true_mean-emp_meansup)){
        empiricmeanssup[i] = emp_meansup
      } else {
        empiricmeanssup[i] = emp_mean
      }
    }
  }
  # Pour les écarts-type
  sd = pilote$ecart_type
  conf_sd = pilote$conf_sd
  # Bornes des intervalles de confiance des écarts-type
  sdinf = conf_sd[1,]
  sdsup = conf_sd[2,]
  # On calcule la puissance grâce à la fonction power du package pwr
  MC_inf = MC_an(n,runs,empiricmeansinf,means,sd,sizes,k)
  MC_sup = MC_an(n,runs,empiricmeanssup,means,sd,sizes,k)
  MC_moy = MC_an(n,runs,empiricmeans,means,sd,sizes,k)
  

  # On présente les résultats sur la puissance:
  # La puissance à partir des paramètres empiriques du pilote, 
  # Puis les intervalles de confiance de la puissance calculés
  # à partir des intervalles de confiance des paramètres.
  # NB : 

  results = data.frame(
    runs = runs,
    Puissance_moy_hand = MC_moy$p5_hand,
    IC_Puissance_hand_inf = MC_inf$p5_hand,
    IC_Puissance_hand_sup = MC_sup$p5_hand,
    Puissance_moy_package = MC_moy$p5_package,
    IC_Puissance_package_inf = MC_inf$p5_package,
    IC_Puissance_package_sup = MC_sup$p5_package
  )
  return (results)
}


Puissance_an<-function(runs_bs_pilote = 1000, runs_MC = 1000, sd = 15 , k = 10, taille_max = 100, dest_puissance, dest_pilote,puissance=NULL){
  # Environnement
  library(pwr)
  library(gplots)
  # Création du pilote
  pilote = pilote_anova(k, sd, runs_bs_pilote,dest_pilote)
  # On regarde la puissance en fonction de la taille d'échantillon
  # (!= npilote, qui est la taille du pilote.
  # ici, la taille de l'échantillon correspond à la taille des tirages pour Monte-Carlo)
  tailles = seq(from = 10, to = taille_max, length.out = 15)
  longueur = length(tailles)
  puissances = numeric(longueur)
  IC_low_width = numeric(longueur)
  IC_up_width = numeric(longueur)
  for (i in 1:longueur){
    results = ttest_anova(tailles[i],runs_MC,pilote)
    puissances[i] = results$Puissance_moy_package
    IC_low_width[i] =  puissances[i] - results$IC_Puissance_package_inf
    IC_up_width[i] = results$IC_Puissance_package_sup - puissances[i]
  }
  jpeg(dest_puissance)
  plotCI(tailles, puissances, uiw = IC_up_width, liw = IC_low_width, type = "o", barcol = "red")
  dev.off()
  results # affiche les puissances pour le dernier tirage de Monte Carlo
  return(calcul_n(puissance,puissances,tailles))
}

n_calc = Puissance_an(dest_puissance =  '/user/6/.base/bonjeang/home/SpeProject/Projet-Specialite-Calcul-de-Puissance/TEST/puissance.jpg',
                       dest_pilote = '/user/6/.base/bonjeang/home/SpeProject/Projet-Specialite-Calcul-de-Puissance/TEST/pilote.jpg',puissance = 0.8)
n_calc
